# LockSupport 
JDK 中的 rt.jar 里面的 `LockSupport` 是个工具类，它的主要作用是挂起和唤醒线程
该工具类是创建锁和其他同步类的基础。AQS阻塞基于LockSupport的方法

1.*park(Thread thread) 方法*：挂起一个线程直到调用这个线程`unpark(Thread thread)`方法或者调用当前线程的`interrupt()`方法

> 注意的一点是 阻塞的线程调用interrupt()被中断后并不会抛出 InterruptedException 异常
```java
//实现一个lock锁
public class LockSupportTest {
    private final AtomicBoolean locked = new AtomicBoolean(false) ;
    private final Queue<Thread> waiters = new ConcurrentLinkedQueue<Thread>();
    public void lock () {
        boolean wasinterrupted = false ;
        Thread current= Thread.currentThread();
        waiters.add(current);
        while (waiters.peek() !=current || !locked.compareAndSet (false , true)) {
            LockSupport.park(this);
            // 因为中断 interrupt 也可以唤醒 park 阻塞，所以在这里用 wasinterrupted 进行标记是否因中断而引起的唤醒，并清除线程自身的中断标记，然后继续循环 park 进行阻塞
            if (Thread.interrupted() ) {
                wasinterrupted = true ;
            }
            }
        waiters.remove();
        //如果当前线程中断过  重新设置在中断标记
        //这一步的原因是lock内不想通过中断来释放锁，但是lock锁住的业务程序会需要中断的状态
        //eg. 
        // current.interrupt(); 中断了
        // lock();   //这里就不会中断
        // current.sleep(1)   //需要中断的业务代码中就会中断
        // unlock();
        if (wasinterrupted){
            current.interrupt();
        }
    }

    public void unlock() {
        locked.set(false);
        LockSupport.unpark(waiters.peek());
    }
}


```

2.*unpark(Thread thread) 方法*：唤醒一个`unpark`阻塞的线程

> 如果先调用unpark在调用park，线程就会直接返回不会阻塞，因为unpark已经提前拿到park的执行许可


# AQS 
AbstractQueuedSynchronizer抽象同步队列简称AQS，实现同步器的基本组件，juc包下的锁的底层基于AQS

![aqs](../../../img/多线程/AQS1.jpg)

AQS是一个FIFO的双向队列，其内部通过节点`head`和`tail`记录队首和队尾元素，队列元素的类型为`Node`，其中`Node`中的`thread`变量用来存放进入AQS队列里面的线程

其中的状态值`state`代表当前资源的锁定状态，分为独占和共享两种操作方法

独占方式：一个资源只能被一个线程锁定，可重入 如 `ReentrantLock`

共享方式：一个资源可以同时被几个线程锁定  如 `ReentrantReadWriteLock`读写锁，读时可被几个线程锁定，但不能同时写操作要等所有读锁释放完毕


## AQS重要方法

### 独占获取与释放资源



```java
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
```


