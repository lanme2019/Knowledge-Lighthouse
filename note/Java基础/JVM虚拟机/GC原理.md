## 对象存活判断

### 引用计数法
引用计数法：在对象中添加一个计数器，每有一个引用就+1，引用失效就-1，为0就不可用

缺点：两个无意义的对象互相引用则不会被GC回收
```java
obja.obj = objb;
objb.obj = obja;
```    

### 可达性分析

可达性分析算法：通过一系列以`GCRoot`为根对象作为起始节点，如果某个对象无法通过引用找到根节点，则对象视为不能使用

java采用可达性分析判断对象存活，但是不可达对象并不是一定会被回收，如果没有重写对象的finalize()方法，或者finalize()方法被执行过一次，才会被回收


![可达分析算法](../../../img/jvm/可达性分析.png)

## 引用的分类

强引用： 垃圾不会回收
软引用： jvm内存满了才会回收
弱引用： 活到下次垃圾回收之前
//todo
虚引用： 无法对对象造成影响

## 分代收集理论

现在的垃圾回收机制建立在分代收集理论之上

分代收集理论：

弱分代假说：绝大多数对象是朝生夕灭的

强分代假说：经历多次回收的对象难易消灭

跨代引用假说：跨代引用占比很小

根据这个理论主要吧内存分为新生代与老年代，新生代中的对象存活时间短，多次GC后的对象会转移到老年代

收集区域分部分收集与整堆收集

部分收集（Partial GC）
- 新生代收集（Minor GC/Young GC）
- 老年代收集（Major GC/Old GC） 目前只有CMSS收集器会有单独收集老年代
- 混合收集（Mixed GC）目前只有G1会收集新生代与部分老年代

整堆收集（Full GC）整个java堆和方法区的收集


## 垃圾回收算法

### 标记清除算法

原理：标记需要回收的对象，集中清除

缺点：
- 如果标记对象过多，标记和清除两个过程效率低
- 会产生大量空间碎片，大对象无法分配

### 标记复制算法

一般是对新生代清理算法

原理：将新生代分为三个区域Eden，From Survivor区，To Survivor区，大小比为8:1:1，每次使用Eden和一个Survivor区，对存活对象进行标记，然后复制到另外一个Survivor区，清除Eden和Survivor区

缺点：
- 对象存活率较高时，需要频繁复制
- 虽然保证了空间利用率达到90%（Eden+Survivor），但是存活对象超过10%，则需要借助老年代的空间

### 标记整理算法

一般是对老年代清理算法

原理：将存活对象集中移动到内存一个区域，然后清除余下的空间

缺点：
- 不仅要标记对象还要进行对象地址的移动，效率低但是适合对象存活时间较长的老年代


## 垃圾回收器

### Serial/SerialOld收集器

Serial收集器 : 采用标记复制算法 回收新生代

SerialOld收集器 : 采用标记整理算法 回收老年代

特点：单线程  回收垃圾时会中断其他工作线程（stop-the-world）

![Serial收集器工作原理](../../../img/jvm/serial收集器.png)


### ParNew收集器

ParNew收集器 : 采用标记复制算法 回收新生代 

特点：是Serial收集器的多线程版本

![ParNew收集器工作原理](../../../img/jvm/parnew收集器.png)
