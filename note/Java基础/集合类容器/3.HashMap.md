HashMap基本算是集合中的必修课了  各个知识点都要理解掌握

# HashMap

## 基本性质

1.JDK7以前使用数组+链表形式 JDK8以后采用数组+链表+红黑树解决Hash冲突之后链表过长的问题

2.线程不安全，不能保证put()和get()的是同一数据。JDK7由于采用头插法容易造成循环链表问题 JDK8采取尾部插入有覆盖数据的问题 保证线程安全可采用concurrentHashMap或采用可以用 Collections类的synchronizedMap的方法

3.默认容量为16，负载因子为0.75，每次扩容2倍

## 属性
```java
//默认的初始容量为16
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
//最大的容量上限为2^30
static final int MAXIMUM_CAPACITY = 1 << 30;
//默认的负载因子为0.75
static final float DEFAULT_LOAD_FACTOR = 0.75f;
//变成树型结构的临界值为8
static final int TREEIFY_THRESHOLD = 8;
//恢复链式结构的临界值为6
static final int UNTREEIFY_THRESHOLD = 6;
/**
 * 哈希表的最小树形化容量
 * 当哈希表中的容量大于这个值时，表中的桶才能进行树形化
 * 否则桶内元素太多时会扩容，而不是树形化
 * 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD
 */
static final int MIN_TREEIFY_CAPACITY = 64;
//哈希表
transient Node<K,V>[] table;
//哈希表中键值对的个数
transient int size;
//哈希表被修改的次数
transient int modCount;
//它是通过capacity*load factor计算出来的，当size到达这个值时，就会进行扩容操作
int threshold;
//负载因子
final float loadFactor;
```
- 思考点1：为什么容量一定是2的n次方

HashMap最大的特点就是根据hash值来快速定位桶（数组）中元素，所以怎么根据hash值散列在桶中的位置就很重要了。假设桶的数量为length个,key 的 hash 值对 length 取余，但是取模运算的消耗很大在计算机中不如位运算，所以在HashMap中key 在数组中的 index = hashCode(key) & length-1，当 length 的值为2的n次方时，等价于对length取余.

以初始长度16为例，16-1=15
2进制表示是00000000 00000000 00001111
和某散列值做“与”操作如下，结果就是截取了最低的四位值

![12](../../../img/集合类/hash的与运算.jpg)

这样做的缺点就是当length值很小时，高位值并没有参与影响到 & 运算，增加了hash碰撞的概率	

但是在JDK8中HashMap并没有直接用Hashcode进行运算，而是又进行了一次hash，优化了高位运算的算法，通过hashCode()的高16位异或(^)低16位，使高位也可以影响index的值


```java
static final int hash(Object key) {   //jdk1.8 & jdk1.7
     int h;
     // h = key.hashCode() 为第一步 取hashCode值
     // h ^ (h >>> 16)  为第二步 高位参与运算
     return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
![12](../../../img/集合类/hash低位运算.jpg)


- 思考点2：为什么负载因子是0.75

考虑到扩容的成本，负载因子太小会造成频繁扩容浪费空间，太大会造成hash碰撞查询时间增加，负载因子可以大于1

- 思考点3：为什么变成树型结构的临界值是8，恢复链式结构的临界值是6

当链表长度为6时 查询的平均长度为 n/2=3，红黑树 log(6) = 2.6 为8时 :链表 8/2=4， 红黑树 log(8)=3，作者根据泊松分布发现链表为8的概率很低

## 方法

1.构造方法
```java
     * @param  initialCapacity the initial capacity
     * @param  loadFactor      the load factor
     * @throws IllegalArgumentException if the initial capacity is negative
     *         or the load factor is nonpositive
     */
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)// 如果构造的初始大小超过允许的最大值 则设为最大值 1 << 30
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);//这步的作用是将初始大小格式化为2的n次方
    }
```
1.1 tableSizeFor方法
```java
    /**
     * Returns a power of two size for the given target capacity.
     * <p>
     *  返回给定目标容量的两倍大小的幂。
     * 
     */
    static final int tableSizeFor(int cap) {
        int n = cap - 1; //为什么要减1呢  如果传进来的值就是2的整数次幂 就会被扩展为2倍不符合实际情况了
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
```
这个怎么理解呢 假设一个数字的2进制 0001xxxxxxx 最高位的1向右移动一位 00001xxxxxx，如果将这两个数字进行按位或 变成00011xxxxxx
再将变为1的两个数字向右移动  也就是移动2位 在进行相同操作  就会有4位1，同理最后移动16位将所有位置都变为1 因为 int 是4字节 32位的所以移动32次

2.put方法
3.remove方法


